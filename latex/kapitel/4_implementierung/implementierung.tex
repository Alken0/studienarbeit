% !TEX root = ../../main.tex
% !TeX spellcheck = de_DE

\chapter{Implementierung}
Dieses Kapitel beinhaltet technische Details zur Umsetzung des GANs.
Die Details beinhalten allgemeinere Projektinformationen und vorgenommene Anpassungen zur Optimierung.

\section{Projekt}
Diese Sektion beinhaltet allgemeine Informationen zum Projekt.
Sie ist insbesondere an die Leser gerichtet, die den Code selbst ausführen oder bei sich einbinden wollen.

\subsection{Umgebung}
Für die Implementierung des GAN werden verschiedene Dependencies genutzt.
Diese sind alle im \textit{Pipfile} definiert und können mit \textit{pipenv install} installiert werden.
Im Gegensatz zu einen \textit{pip install} wird dabei zusätzlich ein Virtual Envirionment erzeugt.
Das Virtual Environment verhindert insbesondere Version Conflicts in Python.
\newline

Aufgrund der trivialen Installation des Projekts werden an dieser Stelle nur die wichtigsten Dependencies für Vergleiche genannt.

Dabei handelt es sich um Python 3.9, Tensorflow 2.6 und Keras 2.8.
Es ist anzumerken, dass Tensorflow mithilfe von CUDA optimiert wurde.
CUDA erlaubt die Ausführung der Trainings auf der GPU, was den Trainingsprozess stark beschleunigt.

\subsection{Konfiguration}
\label{chapter:configuration-hyperparams}
Für das Projekt existieren diverse Hyperparameter, wie zum Beispiel die Anzahl an Bildern pro Label oder auch die exakten Werte für Hyperparameter.
\newline

Alle Konfigurationen können innerhalb der Dateien \textit{configuration.py} und \textit{hyperparameters.py} eingesehen und bearbeitet werden.
Je nach Hyperparameter müssen dann die Bilder erneut generiert werden.
\newline

Hyperparameter, die in der Datei \textit{configuration.py} als Wert den Text \textit{'set by hyperparameters'} haben, werden während des Trainings überschrieben.
Um die Hyperparameter zu ändern, muss die Datei \textit{hyperparameters.py} angepasst werden.
Gewünschte Hyperparameter können dort einfach in der entsprechenden Liste ergänzt werden.

\subsection{Ausführung}
Zunächst sollte der Model Name in der Datei \textit{constants.py} gesetzt werden.
Die Einstellung bestimmt das zu nutzende Modell.
Auch andere Hyperparameter können für das Training geändert werden (\cref{chapter:configuration-hyperparams}).
\newline

Falls zusätzlich zum Training eine Generierung stattfinden soll, muss in der Datei \textit{main.py} zusätzlich der Booleanwert \textit{GENERATE\_IMAGES} auf \textit{True} gesetzt werden.
\newline

Schließlich muss die Datei \textit{main.py} ausgeführt werden.
Das ausgeführte Script startet sowohl Generierungsprozess (falls konfiguriert) als auch das Training.

\subsection{Logs}
Bei den Logs handelt es sich um Bilder, FID-Werte und Graphen für die jeweilige Hyperparameterkombinationen.
Die Logs werden während dem Training automatisch erstellt.
\newline

Um die Logs einzusehen empfiehlt sich die Nutzung von Tensorboard.
Es sollte nach dem \textit{pip install} des \textit{Pipfile}s automatisch installiert sein.
Das Tensorboard kann mit dem Befehl \textit{tensorboard --logdir=data/logs/<model-name>} gestartet werden.

\section{Optimierungen}
Während der Arbeit wurden verschiedene Optimierungen vorgenommen, um entweder Ressourcen zu sparen oder den Trainingsprozess zu beschleunigen.
Die Optimierungen werden im Folgenden vorgestellt.

\subsection{Eigene Trainingsfunktion}\todo{Verständlich?}
Tensorflow bietet eine Standardfunktion zum Traininieren von Neuronalen Netzen mit \textit{model.fit} an.
Die Funktion wird auf ein Model angewendet und führt eine Trainingsepoche auf einen übergebenen Datensatz mit zu übergebenden Parametern durch.
Die Funktion ist für simple Trainingsabläufe wie das Trainieren eines Klassifikatoren sehr gut geeignet.
Allerdings ist sie für den Trainingsablauf bei GANs ineffizient.
\newline

Bei einem GAN müssen Generator und Discriminator beide trainiert werden.
Dafür benötigt der Generator den Losswert des Discriminators auf seine generierten Daten $loss_{unecht} = d(X_{unecht})$.

Der Discriminator soll lernen unechte von echten Daten zu Unterscheiden.
Hierzu kann er mithilfe von Supervised Learning trainiert werden.
Um den Fehler über beide Datensets zu bestimmen müssen die folgenden Operationen ausgeführt werden $loss_{unecht} = d(X_{unecht})$ und $loss_{echt} = d(X_{echt})$.
\newline

Im Trainingsprozess gibt es somit eine Überschneidung, der $loss_{unecht} = d(X_{unecht})$.
Um diesen Losswert wiederzuverwenden benötigt es eine eigene Trainingsfunktion.
Auf der Tensorflow Webseite ist dafür auch eine Alternative Lernfunktion angegeben, die statt \textit{model.fit} verwendet wird \cite{tensorflow-gan-learn-step}.

\subsection{Matplotlib}
Für die Erstellung der Logs werden diverse Bilder erzeugt und abgespeichert.
Bei der Nutzung von Matplotlib muss dafür für jedes Bild zunächst eine Figure erstellt werden.
Die Figure wird benötigt, um das Bild zu konfigurieren.
Es ist dabei nicht möglich, die Figures für verschiedene Bilder vernünftig wiederzuverwenden.
\newline

Das Problem einer großen Anzahl an Figures ist, dass Matplotlib die Figures nicht automatisch bereinigt.
Stattdessen sammeln sich im Hintergrund immer mehr ungenutzte Objekte an.
Das führt zu einem ständig größer werdenden Arbeitsspeicherverbrauch.
Der erhöhte Verbrauch endet dann in einem Overflow Error und Absturz des Programms, in diesem Falle des Trainings.
\newline

Eine Lösung für das Löschen der Figure-Objekte ist die Methode \textit{plt.close('all')}, die von Matplotlib selbst bereitgestellt wird.
Sie löscht alle offenen Instanzen und bereinigt so den Arbeitsspeicher.
Die Methode muss jedoch manuell aufgerufen werden.
\newline

Um eine möglichst optimale Speichernutzung zu garantieren, wird die Funktion während des Trainings nach jedem geschriebenen Log ausgeführt.
Dadurch ist sichergestellt, dass auch lange Trainingsperioden durchgeführt werden können, ohne dass zusätzliche Ressourcen benötigt werden.

\subsection{Tensorflow-Keras}
Bei der Hyperparameteroptimierung werden verschiedene Modelle erzeugt und trainiert.
Tensorflow ist nicht dafür ausgelegt, in einem Durchgang sehr viele Unterschiedliche Modelle zu trainieren.
Es existiert deshalb keine Automatismus, der nicht mehr benötigte Modell im Hintergrund aufräumt.
Dadurch kommt es zu einem stetig steigendem Arbeitsspeicher-Verbrauch.
\newline

Der Speicherverbrauch ist schlecht, da er zum Beispiel das Loggen verhindert.
Die entstehenden Probleme sind so gravierend, dass sie zu einem Abbruch des Lernprozesses führen können.
Die Lösung besteht im manuellen bereinigen der nicht mehr genutzten Modelle.
\newline

Für das Bereinigen stellt Tensorflow die Methode \textit{tf.keras.backend.clear\_session()} bereit.
Um eine möglichst optimale Speichernutzung zu gewährleisten wird die Methode nach jedem fertigen Model-Training aufgerufen.
So wird verhindert, dass Tensorflow gleichzeitig mehr als ein Modell bekannt ist.

\section{Daten-Generator}
Die Daten für das Training vom GAN sind synthetisch generiert mit einem eigens Implementierten Generators.
Der Code für den Generator befindet sich in der Datei \textit{generator.py}.
Die Generierung der Bilder findet automatisch statt, sollte in der Datei \textit{main.py} der Boolean \textit{GENERATE\_IMAGES} auf True gesetzt sein.
\newline

Die Funktionen des Generators basieren auf dem Package skimage.
Bei dem Package handelt es sich um eine Sammlung von Methoden für Image-Processing und Computer Vision \todo{Quelle https://scikit-image.org/docs/dev/api/skimage.html}.
Insbesondere die Methoden zum Zeichnen von Polygonen und Kreisen werden zur Generierung angewendet.
\newline

Für die Generierung werden eine Bildgröße, Formmindestgröße, Formmaximalgröße und Anzahl zu generierender Bilder benötigt.
Die zugehörigen Werte sind in der Konfigurationsdatei \textit{constants.py} angegeben.

Beim Aufruf des Generators wird dann die jeweilige Generierungsfunktion für die Form aufgerufen.
Diese erstellt pro mögliche Größe eine Anzahl an Bildern.
Die Anzahl der Größen ist abhängig von der Anzahl der maximalen Bilder und berechnet sich mit der Formel: $AnzahlProGrö"se = MaximalAnzahlAnBildern / Grö"senKombinationen$.
\newline

Die Position der Form ist zufällig, kann aber durch einen Seed beeinflusst werden, um den Prozess reproduzieren zu können.
Durch die zufallsgesteuerte Positionierung können Positionen identisch sein.
Allerdings sind gleiche Bilder bei den verwendeten Konfigurationen sehr selten. \todo{Analyse gibt es gleiche Bilder?}

